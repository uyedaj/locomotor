x <- -40:20
abline(v=0, lty=2, lwd=1.25)
dum <- lapply(seq(1, length(chainEV.sigmoid$gen), 1), function(i) lines(x, chainEV.sigmoid$beta_left[i]+chainEV.sigmoid$beta_right[i]/(1 + exp(chainEV.sigmoid$beta_slope[i]*(x*10-chainEV.sigmoid$beta_center[i]))), col=makeTransparent(pal[4], alpha=10)))
dum <- lapply(seq(1, length(chainD.linear$gen), 1), function(i) lines(x, chainD.linear$beta_intercept[i]+chainD.linear$beta_slope[i]*x*10, col=makeTransparent(pal[2], alpha=10)))
legend(-40, -3, legend = c("Deciduous", "Evergreen"), col=pal[c(2,4)][as.numeric(td[['phenology']])], bg=makeTransparent(pal[c(2,4)][as.numeric(td[['phenology']])], alpha=100), pch=21)
pal <- setNames(c(rgb(213,94,0, maxColorValue=255),
rgb(230, 159, 0, maxColorValue=255),
rgb(86, 180, 233, maxColorValue=255),
rgb(0,158,115, maxColorValue=255)), c("D_F", "D_NF", "EV_F", "EV_NF"))
plot(td[['tmin.01']]/10, td[['lnVs']], bg=makeTransparent(pal[c(2,4)][as.numeric(td[['phenology']])], alpha=100), col=pal[c(2,4)][as.numeric(td[['phenology']])], main="Temperature vs. vessel size", pch=21, xlab = "Temp (Celsius)", ylab="Log Conduit Diameter", cex.axis=1.25, cex.main=1.25, cex=1.25, cex.lab=1.25)
x <- -40:20
abline(v=0, lty=2, lwd=1.25)
dum <- lapply(seq(1, length(chainEV.sigmoid$gen), 1), function(i) lines(x, chainEV.sigmoid$beta_left[i]+chainEV.sigmoid$beta_right[i]/(1 + exp(chainEV.sigmoid$beta_slope[i]*(x*10-chainEV.sigmoid$beta_center[i]))), col=makeTransparent(pal[4], alpha=10)))
dum <- lapply(seq(1, length(chainD.linear$gen), 1), function(i) lines(x, chainD.linear$beta_intercept[i]+chainD.linear$beta_slope[i]*x*10, col=makeTransparent(pal[2], alpha=10)))
legend(-40, -3, legend = c("Deciduous", "Evergreen"), col=pal[c(2,4)][as.numeric(td[['phenology']])], bg=makeTransparent(pal[c(2,4)][as.numeric(td[['phenology']])], alpha=100), pch=21)
pal <- setNames(c(rgb(213,94,0, maxColorValue=255),
rgb(230, 159, 0, maxColorValue=255),
rgb(86, 180, 233, maxColorValue=255),
rgb(0,158,115, maxColorValue=255)), c("D_F", "D_NF", "EV_F", "EV_NF"))
plot(td[['tmin.01']]/10, td[['lnVs']], bg=makeTransparent(pal[c(2,4)][as.numeric(td[['phenology']])], alpha=100), col=pal[c(2,4)][as.numeric(td[['phenology']])], main="Temperature vs. vessel size", pch=21, xlab = "Temp (Celsius)", ylab="Log Conduit Diameter", cex.axis=1.25, cex.main=1.25, cex=1.25, cex.lab=1.25)
x <- -40:20
abline(v=0, lty=2, lwd=1.25)
dum <- lapply(seq(1, length(chainEV.sigmoid$gen), 1), function(i) lines(x, chainEV.sigmoid$beta_left[i]+chainEV.sigmoid$beta_right[i]/(1 + exp(chainEV.sigmoid$beta_slope[i]*(x*10-chainEV.sigmoid$beta_center[i]))), col=makeTransparent(pal[4], alpha=10)))
dum <- lapply(seq(1, length(chainD.linear$gen), 1), function(i) lines(x, chainD.linear$beta_intercept[i]+chainD.linear$beta_slope[i]*x*10, col=makeTransparent(pal[2], alpha=10)))
legend(-40, -3, legend = c("Deciduous", "Evergreen"), pt.col=pal[c(2,4)][as.numeric(td[['phenology']])],pt.bg=makeTransparent(pal[c(2,4)][as.numeric(td[['phenology']])], alpha=100), pch=21)
pal <- setNames(c(rgb(213,94,0, maxColorValue=255),
rgb(230, 159, 0, maxColorValue=255),
rgb(86, 180, 233, maxColorValue=255),
rgb(0,158,115, maxColorValue=255)), c("D_F", "D_NF", "EV_F", "EV_NF"))
plot(td[['tmin.01']]/10, td[['lnVs']], bg=makeTransparent(pal[c(2,4)][as.numeric(td[['phenology']])], alpha=100), col=pal[c(2,4)][as.numeric(td[['phenology']])], main="Temperature vs. vessel size", pch=21, xlab = "Temp (Celsius)", ylab="Log Conduit Diameter", cex.axis=1.25, cex.main=1.25, cex=1.25, cex.lab=1.25)
x <- -40:20
abline(v=0, lty=2, lwd=1.25)
dum <- lapply(seq(1, length(chainEV.sigmoid$gen), 1), function(i) lines(x, chainEV.sigmoid$beta_left[i]+chainEV.sigmoid$beta_right[i]/(1 + exp(chainEV.sigmoid$beta_slope[i]*(x*10-chainEV.sigmoid$beta_center[i]))), col=makeTransparent(pal[4], alpha=10)))
dum <- lapply(seq(1, length(chainD.linear$gen), 1), function(i) lines(x, chainD.linear$beta_intercept[i]+chainD.linear$beta_slope[i]*x*10, col=makeTransparent(pal[2], alpha=10)))
legend(-40, -3, legend = c("Deciduous", "Evergreen"), col=pal[c(2,4)][as.numeric(td[['phenology']])],pt.bg=makeTransparent(pal[c(2,4)][as.numeric(td[['phenology']])], alpha=100), pch=21)
pal <- setNames(c(rgb(213,94,0, maxColorValue=255),
rgb(230, 159, 0, maxColorValue=255),
rgb(86, 180, 233, maxColorValue=255),
rgb(0,158,115, maxColorValue=255)), c("D_F", "D_NF", "EV_F", "EV_NF"))
plot(td[['tmin.01']]/10, td[['lnVs']], bg=makeTransparent(pal[c(2,4)][as.numeric(td[['phenology']])], alpha=100), col=pal[c(2,4)][as.numeric(td[['phenology']])], main="Temperature vs. vessel size", pch=21, xlab = "Temp (Celsius)", ylab="Log Conduit Diameter", cex.axis=1.25, cex.main=1.25, cex=1.25, cex.lab=1.25)
x <- -40:20
abline(v=0, lty=2, lwd=1.25)
dum <- lapply(seq(1, length(chainEV.sigmoid$gen), 1), function(i) lines(x, chainEV.sigmoid$beta_left[i]+chainEV.sigmoid$beta_right[i]/(1 + exp(chainEV.sigmoid$beta_slope[i]*(x*10-chainEV.sigmoid$beta_center[i]))), col=makeTransparent(pal[4], alpha=10)))
dum <- lapply(seq(1, length(chainD.linear$gen), 1), function(i) lines(x, chainD.linear$beta_intercept[i]+chainD.linear$beta_slope[i]*x*10, col=makeTransparent(pal[2], alpha=10)))
legend(-40, -3, legend = c("Deciduous", "Evergreen"), col=pal[c(2,4)],pt.bg=makeTransparent(pal[c(2,4)], alpha=100), pch=21)
pal <- setNames(c(rgb(213,94,0, maxColorValue=255),
rgb(230, 159, 0, maxColorValue=255),
rgb(86, 180, 233, maxColorValue=255),
rgb(0,158,115, maxColorValue=255)), c("D_F", "D_NF", "EV_F", "EV_NF"))
plot(td[['tmin.01']]/10, td[['lnVs']], bg=makeTransparent(pal[c(2,4)][as.numeric(td[['phenology']])], alpha=100), col=pal[c(2,4)][as.numeric(td[['phenology']])], main="Temperature vs. vessel size", pch=21, xlab = "Temp (Celsius)", ylab="Log Conduit Diameter", cex.axis=1.25, cex.main=1.25, cex=1.25, cex.lab=1.25)
x <- -40:20
abline(v=0, lty=2, lwd=1.25)
dum <- lapply(seq(1, length(chainEV.sigmoid$gen), 1), function(i) lines(x, chainEV.sigmoid$beta_left[i]+chainEV.sigmoid$beta_right[i]/(1 + exp(chainEV.sigmoid$beta_slope[i]*(x*10-chainEV.sigmoid$beta_center[i]))), col=makeTransparent(pal[4], alpha=10)))
dum <- lapply(seq(1, length(chainD.linear$gen), 1), function(i) lines(x, chainD.linear$beta_intercept[i]+chainD.linear$beta_slope[i]*x*10, col=makeTransparent(pal[2], alpha=10)))
legend(-40, -2.5, legend = c("Deciduous", "Evergreen"), col=pal[c(2,4)],pt.bg=makeTransparent(pal[c(2,4)], alpha=100), pch=21)
strees.bayou <- readRDS("../output/OUwie/strees.bayou.rds")
plot(strees.bayou[[1]])
strees.bayou[[1]]
strees
plot(td$phy)
plot(td$phy, show.tip.label=FALSE)
plot(td$phy, show.tip.label=FALSE, type="fan")
dAICs <- apply(sumEV$aics, 1, function(x) x-min(x, na.rm=TRUE))
par(mar=c(10, 4, 1,1))
boxplot(t(dAICs), las=2, xlab="Model", ylab="dAIC", main="EV")
boxplot(t(dAICs), las=2, xlab="Model", ylab="dAIC", main="EV", ylim=c(0,50))
cat("Mean Evergreen dAIC values\n")
apply(t(dAICs), 2, mean)
dAICs <- apply(sumEV$aics, 1, function(x) x-min(x, na.rm=TRUE))
par(mar=c(10, 4, 1,1))
boxplot(t(dAICs), las=2, xlab="Model", ylab="dAIC", main="EV")
boxplot(t(dAICs), las=2, xlab="Model", ylab="dAIC", main="EV", ylim=c(0,50))
cat("Mean Evergreen dAIC values\n")
apply(t(dAICs), 2, mean)
pars <- strees.bayou[[1]][c("sb", "t2", "loc")]
pars <- strees.bayou[[1]][c("sb", "t2", "loc")]
pars$k <- length(pars$sb)
pars$ntheta <- length(midbins)
max(pars$t2)
pars$ntheta
pars <- strees.bayou[[1]][c("sb", "t2", "loc")]
pars$k <- length(pars$sb)
pars$ntheta <- length(midbins)
plotSimmap(pars2simmap(pars, td$phy))
pars$loc
td$phy$edge.length
tree$edge.length
pars <- strees.bayou[[1]][c("sb", "t2", "loc")]
pars$k <- length(pars$sb)
pars$ntheta <- length(midbins)
plotSimmap(pars2simmap(pars, tree))
pars <- strees.bayou[[1]][c("sb", "t2", "loc")]
pars$k <- length(pars$sb)
pars$ntheta <- length(midbins)
plotSimmap(pars2simmap(pars, cache$phy))
pars <- strees.bayou[[1]][c("sb", "t2", "loc")]
pars$k <- length(pars$sb)
pars$ntheta <- length(midbins)
plotSimmap(pars2simmap(pars, reorder(tree, "postorder")))
pars <- strees.bayou[[2]][c("sb", "t2", "loc")]
plotSimmap(pars2simmap(pars, reorder(tree, "postorder")))
## Use diversitree to fit a meristic model:
mkn.lik <- make.mkn.meristic(td$phy, td[['binpred']], k = ncat)
mkn.lik <- constrain(mkn.lik, q.up~q.down)
p <- c(0.1)
fit.mkn <- find.mle(mkn.lik, p)
Q <- matrix(0, ncol=ncat-1, nrow=ncat-1)
for(i in 1:(ncat-2)){
Q[i, i+1] <- fit.mkn$par[1]
Q[i+1, i] <- fit.mkn$par[1]
}
diag(Q) <- apply(Q, 1, sum)*-1
rownames(Q) <- colnames(Q) <- 1:ncol(Q)
simmap2bayou <- function(stree){
shifts <- sapply(stree$maps, function(x) names(x)[-1])
sb <- unlist(sapply(1:length(shifts), function(x) rep(x, length(shifts[[x]]))))
t2 <- as.numeric(unlist(sapply(stree$maps, function(x) names(x)[-1])))
loc <- unlist(sapply(stree$maps, function(x) cumsum(x)[-1]))
return(list(shifts=shifts, sb=sb, t2=t2, loc=loc))
}
#fdfit <- fitDiscrete(td$phy, td[['binpred']], model="meristic")
#Qg <- geiger:::.Qmatrix.from.gfit(fdfit)
td <- reorder(td, "postorder")
stree <- reorderSimmap(make.simmap(td$phy, td[['binpred']], Q=Q), "postorder")
plotSimmap(stree)
pal <- colorRampPalette("#3498db", "#e74c3c")
pal <- colorRampPalette(c("#3498db", "#e74c3c"))
plotSimmap(stree, col=setNames(pal(9), 1:9))
pal <- colorRampPalette(c("#3498db","#f1c40f", "#e74c3c"))
plotSimmap(stree, col=setNames(pal(9), 1:9))
pal <- heat.colors
plotSimmap(stree, col=setNames(pal(9), 1:9))
pal <- viridis:viridis
pal <- viridis::viridis
plotSimmap(stree, col=setNames(pal(9), 1:9))
pal <- viridis::viridis
plotSimmap(stree, col=setNames(pal(9), 1:9))
devtools::install_github("liamrevell/Rphylip/Rphylip")
library(Rphylip)
library(treeplyr)
library(geiger)
library(phytools)
ntaxa <- 50
set.seed(1)
tree <- sim.bdtree(b=1, stop="taxa", n=ntaxa)
tree$edge.length <- tree$edge.length/max(branching.times(tree))
covAB <- 0.9
covAC <- -0.6
covBC <- -0.4
R <- matrix(c(  1,   covAB, covAC,
covAB,     1, covBC,
covAC,  covBC,  1), ncol=3, nrow=3, byrow=TRUE)
colnames(R) <- rownames(R) <- c("A", "B", "C")
R
eigen(R)
dat <- sim.char(tree, par=R, nsim=1, model="BM")[,,1]
colnames(dat) <- c("A", "B", "C")
pairs(dat)
td <- make.treedata(tree, dat)
X <- as.matrix(td[c("A", "B", "C")])
rownames(X) <- td$phy$tip.label
fancyTree(td$phy, type="scattergram", X=X)
td <- mutate(td, a = as.numeric(A > median(A)), b = as.numeric(B > median(B)), c = as.numeric(C > median(C)))
tree <- td$phy
traits <- as.data.frame(td$dat)
rownames(traits) <- td$phy$tip.label
par(mfrow=c(1,1))
plot(tree, show.tip.label=FALSE)
tiplabels(pch=22, bg=traits[['a']])
tiplabels(pch=22, bg=traits[['b']], adj=c(0.53,0.5))
tiplabels(pch=22, bg=traits[['c']], adj=c(0.56,0.5))
library(MCMCglmmRAM)
traits$animal <- factor(tree$tip.label)
prior1 <- list(R=list(V=diag(2)*1e-15, fix=1), G=list(G1=list(V=diag(2), nu=0.002)))
mglmm.AC <- MCMCglmm(cbind(A, C)~trait-1, random=~us(trait):animal, rcov=~us(trait):units,
pedigree=tree, reduced=TRUE, data=traits, prior=prior1,
pr=TRUE, pl=TRUE, family=c("gaussian", "gaussian"), thin=1)
summary(mglmm.AC)
prior2 <- list(R=list(V=diag(2)*1e-15, fix=1), G=list(G1=list(V=diag(2), nu=0.002, fix=2)))
mglmm.aC <- MCMCglmm(cbind(a, C)~trait-1, random=~us(trait):animal, rcov=~us(trait):units,
pedigree=tree, reduced=TRUE, data=traits, prior=prior2,
pr=TRUE, pl=TRUE, family=c("threshold", "gaussian"), thin=1)
summary(mglmm.aC)
prior3 <- list(R=list(V=diag(2)*1e-15, fix=1), G=list(G1=list(V=diag(2), nu=0.002)))
mglmm.ac <- MCMCglmm(cbind(a, c)~trait-1, random=~corg(trait):animal, rcov=~corg(trait):units,
pedigree=tree, reduced=TRUE, data=traits, prior=prior3,
pr=TRUE, pl=TRUE, family=c("threshold", "threshold"), thin=1)
summary(mglmm.ac)
effectiveSize(mglmm.ac$VCV[,2])
#prior4 <- ??
#mglmm.abc <- ??
#summary(mglmm.abc)
postburnin <- floor(0.3*nrow(mglmm.ac$Liab)):nrow(mglmm.ac$Liab)
a.liab <- apply(mglmm.ac$Liab[postburnin,1:ntaxa], 2, mean)
c.liab <- apply(mglmm.ac$Liab[postburnin,(ntaxa+1):(2*ntaxa)], 2, mean)
plot(a.liab, traits$A, pch=21,  bg=traits$a)
plot(c.liab, traits$C, pch=21,  bg=traits$c)
a.nodeLiab <- apply(mglmm.ac$Sol[postburnin, 1:tree$Nnode], 2, mean)
plot(tree, type="fan")
a.pie <- (a.nodeLiab-min(a.nodeLiab))/diff(range(a.nodeLiab))
a.pie <- cbind(a.pie, 1-a.pie)
nodelabels(pie=a.pie, piecol = c("white", "black"), cex=0.5)
tiplabels(pch=21, bg = c("white", "black")[traits$a+1])
plot(tree, type="fan")
a.pie <- (a.nodeLiab-min(a.nodeLiab))/diff(range(a.nodeLiab))
a.pie <- cbind(a.pie, 1-a.pie)
nodelabels(pie=a.pie, piecol = c("black", "white"), cex=0.5)
tiplabels(pch=21, bg = c("black", "white")[traits$a+1])
mglmm.ac$Sol
ncol(mglmm.ac$Sol)
tree$Nnode
a.nodeLiab
length(a.nodeLiab)
tree$Nnode
a.nodeLiab <- apply(mglmm.ac$Sol[postburnin, c(1, 2:(tree$Nnode+1)], 2, mean)
a.nodeLiab <- apply(mglmm.ac$Sol[postburnin, c(1, 2:(tree$Nnode+1))], 2, mean)
a.nodeLiab
a.nodeLiab <- apply(mglmm.ac$Sol[postburnin, c(1, 3:(tree$Nnode+1))], 2, mean)
a.nodeLiab
length(a.nodeLIab)
length(a.nodeLiab)
mglmm.ac$Sol
a.nodeLiab
gsub("traita.animal.Node", "", colnames(a.nodeLiab))
gsub("traita.animal.Node", "", colnames(a.nodeLiab))
gsub("traita.animal.Node", "", names(a.nodeLiab))
names(a.nodeLiab) <- gsub("traita.animal.Node", "", names(a.nodeLiab))
a.nodeLiab
names(a.nodeLiab)[1] <- 1
a.nodeLiab[1:tree$Nnode]
a.nodeLiab[as.character(1:tree$Nnode)]
a.nodeLiab <- a.nodeLiab[as.character(1:tree$Nnode)]
plot(tree, type="fan")
a.pie <- (a.nodeLiab-min(a.nodeLiab))/diff(range(a.nodeLiab))
a.pie <- cbind(a.pie, 1-a.pie)
nodelabels(pie=a.pie, piecol = c("black", "white"), cex=0.5)
tiplabels(pch=21, bg = c("black", "white")[traits$a+1])
tree$edge
a.nodeLiab <- apply(mglmm.ac$Sol[postburnin, c(1, 3:(tree$Nnode+1))], 2, mean)
names(a.nodeLiab) <- gsub("traita.animal.Node", "", names(a.nodeLiab))
names(a.nodeLiab)[1] <- 1
a.nodeLiab <- a.nodeLiab[as.character(1:tree$Nnode)]
plot(tree, type="fan")
a.pie <- (a.nodeLiab-min(a.nodeLiab))/diff(range(a.nodeLiab))
a.pie <- cbind(a.pie, 1-a.pie)
nodelabels(pie=a.pie, piecol = c("black", "white"), cex=0.5)
tiplabels(pch=21, bg = c("black", "white")[traits$a+1])
a.nodeLiab <- apply(mglmm.ac$Sol[postburnin, c(1, 3:(tree$Nnode+1))], 2, mean)
#names(a.nodeLiab) <- gsub("traita.animal.Node", "", names(a.nodeLiab))
#names(a.nodeLiab)[1] <- 1
#a.nodeLiab <- a.nodeLiab[as.character(1:tree$Nnode)]
plot(tree, type="fan")
a.pie <- (a.nodeLiab-min(a.nodeLiab))/diff(range(a.nodeLiab))
a.pie <- cbind(a.pie, 1-a.pie)
nodelabels(pie=a.pie, piecol = c("black", "white"), cex=0.5)
tiplabels(pch=21, bg = c("black", "white")[traits$a+1])
plot(tree, type="fan")
a.pie <- (a.nodeLiab-min(a.nodeLiab))/diff(range(a.nodeLiab))
a.pie <- cbind(a.pie, 1-a.pie)
nodelabels(pie=a.pie, piecol = c("white", "black"), cex=0.5)
tiplabels(pch=21, bg = c("white", "black")[traits$a+1])
plot(tree, type="fan")
a.pie <- (a.nodeLiab-min(a.nodeLiab))/diff(range(a.nodeLiab))
a.pie <- cbind(a.pie, 1-a.pie)
nodelabels(pie=a.pie, piecol = c("white", "black"), cex=0.5)
tiplabels(pch=21, bg = c("black", "white")[traits$a+1])
a.nodeLiab <- apply(mglmm.ac$Sol[postburnin, c(1, 3:(tree$Nnode+1))], 2, mean)
names(a.nodeLiab) <- gsub("traita.animal.Node", "", names(a.nodeLiab))
names(a.nodeLiab)[1] <- 1
a.nodeLiab <- a.nodeLiab[as.character(1:tree$Nnode)]
plot(tree, type="fan")
a.pie <- (a.nodeLiab-min(a.nodeLiab))/diff(range(a.nodeLiab))
a.pie <- cbind(a.pie, 1-a.pie)
nodelabels(pie=a.pie, piecol = c("white", "black"), cex=0.5)
tiplabels(pch=21, bg = c("black", "white")[traits$a+1])
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(abind)
library(phytools)
library(geiger)
#' Plot outlines of taxa forms
#' @param traits Matrix of measurements; rownames are taxa, cols are traits
#' @param n Number of taxa in matrix to plot
#' @param color Color to use
PlotForms <- function(traits, n=NULL, color=rgb(0,0,0,.5)) {
x.values <- unlist(traits[seq(from=1, to=ncol(traits), by=2),])
y.values <- unlist(traits[seq(from=2, to=ncol(traits), by=2),])
plot(x.values, y.values, type="n", bty="n",asp=1)
if(is.null(n)) {
n=nrow(traits)
}
for (taxon.index in sequence(n)) {
PlotSingleForm(traits[taxon.index,], color=color)
}
}
#' Plot a single taxon
#' @param trait.vector A vector of values: x is odd entries, y are even
#' @param color Color of lines
PlotSingleForm <- function(trait.vector, color=rgb(0,0,0,.5)) {
x.values <- unlist(trait.vector[seq(from=1, to=length(trait.vector), by=2)])
y.values <- unlist(trait.vector[seq(from=2, to=length(trait.vector), by=2)])
#lines(point.matrix$x, point.matrix$y, col=color)
polygon(x.values, y.values, border=color)
}
#' Plot outlines of taxa forms
#' @param traits Matrix of measurements; rownames are taxa, cols are traits
#' @param pc Principal components to plot
#' @param just.mean If TRUE, plots the mean points; if FALSE, overplots all the fish
PlotMeanAndPC <- function(traits, pc=NULL, just.mean=TRUE) {
x.values <- unlist(traits[seq(from=1, to=ncol(traits), by=2),])
y.values <- unlist(traits[seq(from=2, to=ncol(traits), by=2),])
plot(x.values, y.values, type="n", bty="n",asp=1)
all.means <- apply(traits, 2, mean)
x.means <- all.means[seq(from=1, to=ncol(traits), by=2)]
y.means <- all.means[seq(from=2, to=ncol(traits), by=2)]
x.pc <- pc[seq(from=1, to=ncol(traits), by=2)]
y.pc <- pc[seq(from=2, to=ncol(traits), by=2)]
if(just.mean) {
PlotSingleForm(all.means, color=rgb(0,0,0,.5))
} else {
PlotForms(traits, color=rgb(0,0,0,.05))
PlotSingleForm(all.means, color="black")
}
if(!is.null(pc)) {
for (i in sequence(length(x.pc))) {
arrows(x0=x.means[i], y0=y.means[i], x1=x.means[i]+x.pc[i], y1=y.means[i]+y.pc[i],  length = 0.05, angle = 20, col = "red", lwd = 4)
}
}
}
phy <- ape::read.tree("tree.tre")
phy <- ape::reorder.phylo(phy)
data1 <- geiger::treedata(phy, read.table("dataset1.txt", row.names=1), sort=TRUE)$data
data2 <- geiger::treedata(phy, read.table("dataset2.txt", row.names=1), sort=TRUE)$data
data3 <- geiger::treedata(phy, read.table("dataset3.txt", row.names=1), sort=TRUE)$data
data4 <- geiger::treedata(phy, read.table("dataset4.txt", row.names=1), sort=TRUE)$data
data5 <- geiger::treedata(phy, read.table("dataset5.txt", row.names=1), sort=TRUE)$data
phy <- geiger::treedata(phy, data1, sort=TRUE)$phy #and do the same for the phylo object
all.data <- abind::abind(data1, data2, data3, data4, data5, along=3) #makes a 3d array.
PlotForms(data1)
pic.scaled <- apply(data1, 2, ape::pic, phy=phy, scaled=TRUE)
print("Original dataset size")
print(dim(data1))
print("PIC dataset")
print(dim(pic.scaled))
x.trait <- 1
y.trait <- 2
phytools::phylomorphospace(phy, data1[,c(x.trait,y.trait)])
plot(data1[,x.trait], data1[,y.trait], xlab=colnames(data1)[x.trait], ylab=colnames(data1)[y.trait], bty="n", pch=20, col=rgb(0,0,0,.5), main="Raw species traits")
lm.result <- lm(paste(colnames(data1)[y.trait],"~",colnames(data1)[x.trait], sep=" "), data=data.frame(data1))
abline(lm.result)
plot(pic.scaled[,x.trait], pic.scaled[,y.trait], xlab=colnames(pic.scaled)[x.trait], ylab=colnames(pic.scaled)[y.trait], bty="n", pch=20, col=rgb(0,0,0,.5), main="Contrasts")
lm.result <- lm(paste(colnames(pic.scaled)[y.trait],"~",colnames(pic.scaled)[x.trait], "- 1", sep=" "), data=data.frame(pic.scaled))
abline(lm.result)
par(mfcol=c(min(5, ncol(pic.scaled)), min(5, ncol(pic.scaled))))
for (i in sequence(min(5, ncol(pic.scaled)))) {
for (j in sequence(min(5, ncol(pic.scaled)))) {
if (i!=j) {
x.trait <- i
y.trait <- j
plot(pic.scaled[,x.trait], pic.scaled[,y.trait], xlab=colnames(pic.scaled)[x.trait], ylab=colnames(pic.scaled)[y.trait], bty="n", pch=20, col=rgb(0,0,0,.5))
lm.result <- lm(paste(colnames(pic.scaled)[y.trait],"~",colnames(pic.scaled)[x.trait], "- 1", sep=" "), data=data.frame(pic.scaled))
abline(lm.result)
} else {
contMap(phy, data1[,i])
}
}
}
sim.phy <- compute.brlen(ape::stree(2^7, type="balanced"))
plot(sim.phy, show.tip.label=FALSE)
sim.traits <- geiger::sim.char(sim.phy, par=matrix(c(1, 0.0, 0.0, 1), nrow=2, byrow=TRUE), nsim=1, model="BM")[,,1]
par(mfcol=c(1,2))
plot(sim.traits[,1], sim.traits[,2], bty="n", main="Raw (truth = uncorrelated)")
pic1 <- pic(sim.traits[,1], phy=sim.phy)
pic2 <- pic(sim.traits[,2], phy=sim.phy)
plot(pic1, pic2, bty="n", main="PIC (truth = uncorrelated)")
sim.traits <- geiger::sim.char(sim.phy, par=matrix(c(1, 0.5, 0.5, 1), nrow=2, byrow=TRUE), nsim=1, model="BM")[,,1]
par(mfcol=c(1,2))
plot(sim.traits[,1], sim.traits[,2], bty="n", main="Raw (truth = correlated)")
pic1 <- pic(sim.traits[,1], phy=sim.phy)
pic2 <- pic(sim.traits[,2], phy=sim.phy)
plot(pic1, pic2, bty="n", main="PIC (truth = correlated)")
PC <- runif(ncol(data1)) #just making them up, REPLACE THIS
PlotMeanAndPC(data1, PC, just.mean=FALSE)
data1
all.data
bayou::bayou.mcmc
?bayou::bayou.mcmc
data1
class(data())
class(data1
)
data1[,2]
as.data.frame(data1[,2])
as.data.frame(data1)[,2]
library(treeplyr)
library(bayou)
library(rotl)
library(phytools)
library(Matrix)
library(phylolm)
source("BMRstudyFunctions.R")
setwd("~/repos/bmr/R/")
## Read in the dataset
allwhite <- read.csv("../datasets/all_white_etal.csv")
## Boltzmann's constant & temperature to estimate metabolic rate at using Arrhenius equation
k <- 8.617332478E-5
T2 <- 293.15
allwhite <- mutate(allwhite, lnBMR = log(MR), lnMass = log(mass), iTemp = 1/k*1/(temp+273.15))
## Fit a multiple regression model to estimate the average Ei value across species
tmp <- filter(allwhite, !is.na(mass), !is.na(temp), !is.na(MR))
mod1 <- lm(lnBMR ~ lnMass + iTemp + species, data=tmp)
Ei <- mod1$coef[3]
## Some data don't have raw masses, only mean mass. Here we take the log of the means as an estimate of the mean of the logs.
allwhite[which(is.na(allwhite[,2])),'mass'] <- sapply(allwhite[which(is.na(allwhite[,2])),1], function(x) mean(allwhite$mean.mass[which(allwhite$species==x)], na.rm=TRUE))
allwhite <- filter(allwhite, !is.na(mass), !is.na(temp), !is.na(MR)) %>%  mutate(., lnBMR = log(MR), lnMass = log(mass), iTemp = 1/k*1/(temp+T2))
new.dat <- group_by(allwhite, species) %>% summarize(., lnMass = mean(lnMass), lnBMR = mean(lnBMR) + Ei/k*(mean(1/(temp+273.15)) - 1/T2)) %>% arrange(., species)
new.dat
## Load in individual trees for each taxonomic group
amphib <- read.tree("../datasets/amph.tre")
birds <- read.tree("../datasets/bird.tre")
squam <- read.tree("../datasets/squa.tre")
mamm <- read.tree("../datasets/fullnewmammal.tre")
fish <- read.tree("../datasets/fish.tre")
## Make a taxonomy table:
trees <- list(fish=fish, amphib=amphib, squam=squam, birds=birds, mamm=mamm)
trees <- lapply(trees, function(x) reorder(x, "postorder"))
ntips <- sum(sapply(trees, function(x) length(x$tip.label)))
tip.labels <- c("fish", "amphib", "squam", "birds", "mamm")
classes <- lapply(1:length(c("fish", "amphibians", "squamates", "birds", "mammals")), function(x) data.frame("genspec"=trees[[x]]$tip.label, "class"=c("fish", "amphibians", "squamates", "birds", "mammals")[x]))
classes <- do.call(rbind, classes)
## Make a tree with just orders:
edge <- matrix(c(9, 4,
9, 3,
8, 5,
8, 9,
7, 8,
7, 2,
6, 7,
6, 1), byrow=TRUE, ncol=2)
## Dates from Timetree of life (timetree.org)
edge.length <- c(274.9, 274.9, 324.5, 324.5-274.9, 382.9-324.5, 382.9, 454.6-382.9 , 454.6)
Nnode <- 4
ordertree <- list(edge=edge, Nnode=Nnode, tip.label=tip.labels, edge.length=edge.length)
class(ordertree) <- 'phylo'
ordertree <- reorder(ordertree, "postorder")
plot(ordertree)
##
otax <- data.frame("Class"= ordertree$tip.label, "Superclass"=c("Actinopterygii", rep("Tetrapoda",4)))
rownames(otax) <- ordertree$tip.label
classtree <- nodelabel.phylo(ordertree, otax, ncores=1)
trees <- lapply(trees, multi2di)
class(trees) <- "multiPhylo"
plot(classtree)
#abline(v=sapply(trees, function(x) max(nodeHeights(x))),lty=2)
res <- glomogram.phylo(classtree, trees)
length(res$tip.label)
sum(res$edge.length)
#write.tree(res, file="../output/tetrapods.tre")
missing <- setdiff(new.dat[[1]], vertTree$tip.label)
td <- make.treedata(vertTree, clean.dat)
vertTree <- read.tree("../datasets/tetrapods.tre")
length(vertTree$tip.label)
missing <- setdiff(new.dat[[1]], vertTree$tip.label)
otl_missing <- ttol_queryOttIds(missing, nrequest=500, tree=FALSE)
clean.dat <- new.dat
clean.dat[[1]] <- as.character(clean.dat[[1]])
clean.dat[[1]][match(missing, new.dat[[1]])] <- otl_missing$ttol
## Manual changes to match tree:
clean.dat$species[clean.dat$species=="Urocitellus_townsendii"] <- "Urocitellus_townsendi"
td <- make.treedata(vertTree, clean.dat)
patches <- read.csv("../datasets/BMR_corrected.csv")
patches2 <- read.csv("../datasets/BMR_corrected2.csv")
td$dat[match(patches2$taxon, td$phy$tip.label),] <- data.frame("lnMass"=log(patches2$newMass.g), "lnBMR"=patches2$NewRate.20)
drop <- patches$taxon[which(patches$action %in% c("cut"))]
td <- treeply(td, drop.tip, as.character(drop))
#saveRDS(td, "../output/data/tetrapods_ei.rds")
td
filter(td)
library(treeplyr)
devtools::install_github("uyedaj/bayou", ref="dev")
library(bayou)
library(rotl)
library(phytools)
library(Matrix)
library(phylolm)
setwd("~/repos/locomotor/R/")
tree <- read.tree(file="../data/tetrapods.tre")
locomotor <- read.csv("../data/Locomotor_Performance_Database_002.csv")
locomotor <- mutate(locomotor, genspec = gsub(" " ,"_", TaxaID))
locomotor$LnMass[locomotor$LnMass=="Err:502"] <- NA
locomotor$Thermy[locomotor$Thermy=="ectotherm"] <- "Ectotherm"
locomotor$Thermy[locomotor$Thermy=="endotherm"] <- "Endotherm"
td <- make.treedata(tree, locomotor)
traits <- levels(locomotor$Locomotor.Trait)
tds <- list()
for(i in 1:length(traits)){
.data <- filter(locomotor, Locomotor.Trait==traits[i])
tds[[i]] <- try(make.treedata(tree, .data))
if(class(tds[[i]])=="try-error"){
tds[[i]] <- .data
}
}
names(tds) <- traits
plot(tds$`Maximum Speed`[['LnMass']], tds$`Maximum Speed`[['TempTraitValue']], pch=21, bg=as.numeric(tds$`Maximum Speed`[['Order']]))
plot(td[['LnMass']], td[['TempTraitValue']], ylim=c(0,4), pch=21, bg=as.numeric(td[['Thermy']]))
td
plot(tds$`Maximum Speed`[['LnMass']], tds$`Maximum Speed`[['TempTraitValue']], pch=21, bg=as.numeric(tds$`Maximum Speed`[['Order']]))
tds
plot(tds$`Maximum Speed`[['LnMass']], tds$`Maximum Speed`[['TempTraitValue']], pch=21, bg=as.numeric(tds$`Maximum Speed`[['Order']]))
sapply(tds, function(x) length(x$tip.label))
sapply(tds, function(x) length(x$phy$tip.label))
do.call(rbind, lapply(tds, function(x) length(x$phy$tip.label)))
